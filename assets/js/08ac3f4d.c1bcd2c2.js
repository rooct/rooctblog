"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4829],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return d}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=c(t),d=r,b=m["".concat(s,".").concat(d)]||m[d]||u[d]||i;return t?a.createElement(b,o(o({ref:n},p),{},{components:t})):a.createElement(b,o({ref:n},p))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var c=2;c<i;c++)o[c]=t[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},1605:function(e,n,t){t.r(n),t.d(n,{contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return p}});var a=t(7462),r=t(3366),i=(t(7294),t(3905)),o=["components"],l={title:"Bi-Directional Payment Channel",version:"0.8.10",description:"An example of bi-directional payment channels in Solidity"},s=void 0,c={unversionedId:"example/app/BiDirectionalPaymentChannel",id:"example/app/BiDirectionalPaymentChannel",isDocsHomePage:!1,title:"Bi-Directional Payment Channel",description:"An example of bi-directional payment channels in Solidity",source:"@site/docs/example/app/BiDirectionalPaymentChannel.md",sourceDirName:"example/app",slug:"/example/app/BiDirectionalPaymentChannel",permalink:"/rooctblog/docs/example/app/BiDirectionalPaymentChannel",tags:[],version:"current",frontMatter:{title:"Bi-Directional Payment Channel",version:"0.8.10",description:"An example of bi-directional payment channels in Solidity"},sidebar:"docs",previous:{title:"Error",permalink:"/rooctblog/docs/api/Error"},next:{title:"Create2",permalink:"/rooctblog/docs/example/app/Create2"}},p=[],u={toc:p};function m(e){var n=e.components,t=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Bi-directional payment channels allow participants ",(0,i.kt)("inlineCode",{parentName:"p"},"Alice")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Bob")," to repeatedly transfer Ether off chain."),(0,i.kt)("p",null,"Payments can go both ways, ",(0,i.kt)("inlineCode",{parentName:"p"},"Alice")," pays ",(0,i.kt)("inlineCode",{parentName:"p"},"Bob")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Bob")," pays ",(0,i.kt)("inlineCode",{parentName:"p"},"Alice"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\n/*\nOpening a channel\n1. Alice and Bob fund a multi-sig wallet\n2. Precompute payment channel address\n3. Alice and Bob exchanges signatures of initial balances\n4. Alice and Bob creates a transaction that can deploy a payment channel from\n   the multi-sig wallet\n\nUpdate channel balances\n1. Repeat steps 1 - 3 from opening a channel\n2. From multi-sig wallet create a transaction that will\n   - delete the transaction that would have deployed the old payment channel\n   - and then create a transaction that can deploy a payment channel with the\n     new balances\n\nClosing a channel when Alice and Bob agree on the final balance\n1. From multi-sig wallet create a transaction that will\n   - send payments to Alice and Bob\n   - and then delete the transaction that would have created the payment channel\n\nClosing a channel when Alice and Bob do not agree on the final balances\n1. Deploy payment channel from multi-sig\n2. call challengeExit() to start the process of closing a channel\n3. Alice and Bob can withdraw funds once the channel is expired\n*/\n\nimport "github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.5/contracts/utils/math/SafeMath.sol";\nimport "github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.5/contracts/utils/cryptography/ECDSA.sol";\n\ncontract BiDirectionalPaymentChannel {\n    using SafeMath for uint;\n    using ECDSA for bytes32;\n\n    event ChallengeExit(address indexed sender, uint nonce);\n    event Withdraw(address indexed to, uint amount);\n\n    address payable[2] public users;\n    mapping(address => bool) public isUser;\n\n    mapping(address => uint) public balances;\n\n    uint public challengePeriod;\n    uint public expiresAt;\n    uint public nonce;\n\n    modifier checkBalances(uint[2] memory _balances) {\n        require(\n            address(this).balance >= _balances[0].add(_balances[1]),\n            "balance of contract must be >= to the total balance of users"\n        );\n        _;\n    }\n\n    // NOTE: deposit from multi-sig wallet\n    constructor(\n        address payable[2] memory _users,\n        uint[2] memory _balances,\n        uint _expiresAt,\n        uint _challengePeriod\n    ) payable checkBalances(_balances) {\n        require(_expiresAt > block.timestamp, "Expiration must be > now");\n        require(_challengePeriod > 0, "Challenge period must be > 0");\n\n        for (uint i = 0; i < _users.length; i++) {\n            address payable user = _users[i];\n\n            require(!isUser[user], "user must be unique");\n            users[i] = user;\n            isUser[user] = true;\n\n            balances[user] = _balances[i];\n        }\n\n        expiresAt = _expiresAt;\n        challengePeriod = _challengePeriod;\n    }\n\n    function verify(\n        bytes[2] memory _signatures,\n        address _contract,\n        address[2] memory _signers,\n        uint[2] memory _balances,\n        uint _nonce\n    ) public pure returns (bool) {\n        for (uint i = 0; i < _signatures.length; i++) {\n            /*\n            NOTE: sign with address of this contract to protect\n                  agains replay attack on other contracts\n            */\n            bool valid = _signers[i] ==\n                keccak256(abi.encodePacked(_contract, _balances, _nonce))\n                    .toEthSignedMessageHash()\n                    .recover(_signatures[i]);\n\n            if (!valid) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    modifier checkSignatures(\n        bytes[2] memory _signatures,\n        uint[2] memory _balances,\n        uint _nonce\n    ) {\n        // Note: copy storage array to memory\n        address[2] memory signers;\n        for (uint i = 0; i < users.length; i++) {\n            signers[i] = users[i];\n        }\n\n        require(\n            verify(_signatures, address(this), signers, _balances, _nonce),\n            "Invalid signature"\n        );\n\n        _;\n    }\n\n    modifier onlyUser() {\n        require(isUser[msg.sender], "Not user");\n        _;\n    }\n\n    function challengeExit(\n        uint[2] memory _balances,\n        uint _nonce,\n        bytes[2] memory _signatures\n    )\n        public\n        onlyUser\n        checkSignatures(_signatures, _balances, _nonce)\n        checkBalances(_balances)\n    {\n        require(block.timestamp < expiresAt, "Expired challenge period");\n        require(_nonce > nonce, "Nonce must be greater than the current nonce");\n\n        for (uint i = 0; i < _balances.length; i++) {\n            balances[users[i]] = _balances[i];\n        }\n\n        nonce = _nonce;\n        expiresAt = block.timestamp.add(challengePeriod);\n\n        emit ChallengeExit(msg.sender, nonce);\n    }\n\n    function withdraw() public onlyUser {\n        require(block.timestamp >= expiresAt, "Challenge period has not expired yet");\n\n        uint amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n\n        (bool sent, ) = msg.sender.call{value: amount}("");\n        require(sent, "Failed to send Ether");\n\n        emit Withdraw(msg.sender, amount);\n    }\n}\n\n')))}m.isMDXComponent=!0}}]);