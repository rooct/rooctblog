"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[453],{3905:function(n,e,t){t.d(e,{Zo:function(){return l},kt:function(){return c}});var r=t(7294);function o(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function s(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function a(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?s(Object(t),!0).forEach((function(e){o(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function i(n,e){if(null==n)return{};var t,r,o=function(n,e){if(null==n)return{};var t,r,o={},s=Object.keys(n);for(r=0;r<s.length;r++)t=s[r],e.indexOf(t)>=0||(o[t]=n[t]);return o}(n,e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);for(r=0;r<s.length;r++)t=s[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(o[t]=n[t])}return o}var u=r.createContext({}),d=function(n){var e=r.useContext(u),t=e;return n&&(t="function"==typeof n?n(e):a(a({},e),n)),t},l=function(n){var e=d(n.components);return r.createElement(u.Provider,{value:e},n.children)},y={inlineCode:"code",wrapper:function(n){var e=n.children;return r.createElement(r.Fragment,{},e)}},x=r.forwardRef((function(n,e){var t=n.components,o=n.mdxType,s=n.originalType,u=n.parentName,l=i(n,["components","mdxType","originalType","parentName"]),x=d(t),c=o,p=x["".concat(u,".").concat(c)]||x[c]||y[c]||s;return t?r.createElement(p,a(a({ref:e},l),{},{components:t})):r.createElement(p,a({ref:e},l))}));function c(n,e){var t=arguments,o=e&&e.mdxType;if("string"==typeof n||o){var s=t.length,a=new Array(s);a[0]=x;var i={};for(var u in e)hasOwnProperty.call(e,u)&&(i[u]=e[u]);i.originalType=n,i.mdxType="string"==typeof n?n:o,a[1]=i;for(var d=2;d<s;d++)a[d]=t[d];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}x.displayName="MDXCreateElement"},7945:function(n,e,t){t.r(e),t.d(e,{contentTitle:function(){return u},default:function(){return x},frontMatter:function(){return i},metadata:function(){return d},toc:function(){return l}});var r=t(7462),o=t(3366),s=(t(7294),t(3905)),a=["components"],i={title:"Constant Product AMM",version:"0.8.10",description:"Constant product AMM"},u=void 0,d={unversionedId:"Example/defi/CPAMM",id:"Example/defi/CPAMM",isDocsHomePage:!1,title:"Constant Product AMM",description:"Constant product AMM",source:"@site/docs/Example/defi/CPAMM.md",sourceDirName:"Example/defi",slug:"/Example/defi/CPAMM",permalink:"/rooctblog/docs/Example/defi/CPAMM",tags:[],version:"current",frontMatter:{title:"Constant Product AMM",version:"0.8.10",description:"Constant product AMM"},sidebar:"tutorialSidebar",previous:{title:"Upgradeable Proxy",permalink:"/rooctblog/docs/Example/app/UpgradeableProxy"},next:{title:"Constant Sum AMM",permalink:"/rooctblog/docs/Example/defi/CSamm"}},l=[],y={toc:l};function x(n){var e=n.components,t=(0,o.Z)(n,a);return(0,s.kt)("wrapper",(0,r.Z)({},y,t,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Constant product AMM ",(0,s.kt)("inlineCode",{parentName:"p"},"XY = K")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ncontract CPAMM {\n    IERC20 public immutable token0;\n    IERC20 public immutable token1;\n\n    uint public reserve0;\n    uint public reserve1;\n\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n\n    constructor(address _token0, address _token1) {\n        token0 = IERC20(_token0);\n        token1 = IERC20(_token1);\n    }\n\n    function _mint(address _to, uint _amount) private {\n        balanceOf[_to] += _amount;\n        totalSupply += _amount;\n    }\n\n    function _burn(address _from, uint _amount) private {\n        balanceOf[_from] -= _amount;\n        totalSupply -= _amount;\n    }\n\n    function _update(uint _reserve0, uint _reserve1) private {\n        reserve0 = _reserve0;\n        reserve1 = _reserve1;\n    }\n\n    function swap(address _tokenIn, uint _amountIn) external returns (uint amountOut) {\n        require(\n            _tokenIn == address(token0) || _tokenIn == address(token1),\n            "invalid token"\n        );\n\n        bool isToken0 = _tokenIn == address(token0);\n\n        (IERC20 tokenIn, IERC20 tokenOut, uint reserveIn, uint reserveOut) = isToken0\n            ? (token0, token1, reserve0, reserve1)\n            : (token1, token0, reserve1, reserve0);\n\n        tokenIn.transferFrom(msg.sender, address(this), _amountIn);\n        uint amountIn = tokenIn.balanceOf(address(this)) - reserveIn;\n\n        /*\n        How much dy for dx?\n\n        xy = k\n        (x + dx)(y - dy) = k\n        y - dy = k / (x + dx)\n        y - k / (x + dx) = dy\n        y - xy / (x + dx) = dy\n        (yx + ydx - xy) / (x + dx) = dy\n        ydx / (x + dx) = dy\n        */\n        // 0.3% fee\n        uint amountInWithFee = (amountIn * 997) / 1000;\n        amountOut = (reserveOut * amountInWithFee) / (reserveIn + amountInWithFee);\n\n        (uint res0, uint res1) = isToken0\n            ? (reserveIn + amountIn, reserveOut - amountOut)\n            : (reserveOut - amountOut, reserveIn + amountIn);\n\n        _update(res0, res1);\n        tokenOut.transfer(msg.sender, amountOut);\n    }\n\n    function addLiquidity(uint _amount0, uint _amount1) external returns (uint shares) {\n        token0.transferFrom(msg.sender, address(this), _amount0);\n        token1.transferFrom(msg.sender, address(this), _amount1);\n\n        uint bal0 = token0.balanceOf(address(this));\n        uint bal1 = token1.balanceOf(address(this));\n\n        uint d0 = bal0 - reserve0;\n        uint d1 = bal1 - reserve1;\n\n        /*\n        How much dx, dy to add?\n\n        xy = k\n        (x + dx)(y + dy) = k\'\n\n        No price change, before and after adding liquidity\n        x / y = (x + dx) / (y + dy)\n\n        x(y + dy) = y(x + dx)\n        x * dy = y * dx\n\n        x / y = dx / dy\n        dy = y / x * dx\n        */\n        if (reserve0 > 0 || reserve1 > 0) {\n            require(reserve0 * d1 == reserve1 * d0, "x / y != dx / dy");\n        }\n\n        /*\n        How much shares to mint?\n\n        f(x, y) = value of liquidity\n        We will define f(x, y) = sqrt(xy)\n\n        L0 = f(x, y)\n        L1 = f(x + dx, y + dy)\n        T = total shares\n        s = shares to mint\n\n        Total shares should increase proportional to increase in liquidity\n        L1 / L0 = (T + s) / T\n\n        L1 * T = L0 * (T + s)\n\n        (L1 - L0) * T / L0 = s \n        */\n\n        /*\n        Claim\n        (L1 - L0) / L0 = dx / x = dy / y\n\n        Proof\n        --- Equation 1 ---\n        (L1 - L0) / L0 = (sqrt((x + dx)(y + dy)) - sqrt(xy)) / sqrt(xy)\n        \n        dx / dy = x / y so replace dy = dx * y / x\n\n        --- Equation 2 ---\n        Equation 1 = (sqrt(xy + 2ydx + dx^2 * y / x) - sqrt(xy)) / sqrt(xy)\n\n        Multiply by sqrt(x) / sqrt(x)\n        Equation 2 = (sqrt(x^2y + 2xydx + dx^2 * y) - sqrt(x^2y)) / sqrt(x^2y)\n                   = (sqrt(y)(sqrt(x^2 + 2xdx + dx^2) - sqrt(x^2)) / (sqrt(y)sqrt(x^2))\n        \n        sqrt(y) on top and bottom cancels out\n\n        --- Equation 3 ---\n        Equation 2 = (sqrt(x^2 + 2xdx + dx^2) - sqrt(x^2)) / (sqrt(x^2)\n        = (sqrt((x + dx)^2) - sqrt(x^2)) / sqrt(x^2)  \n        = ((x + dx) - x) / x\n        = dx / x\n\n        Since dx / dy = x / y,\n        dx / x = dy / y\n\n        Finally\n        (L1 - L0) / L0 = dx / x = dy / y\n        */\n\n        if (totalSupply > 0) {\n            shares = _min((d0 * totalSupply) / reserve0, (d1 * totalSupply) / reserve1);\n        } else {\n            shares = _sqrt(d0 * d1);\n        }\n        require(shares > 0, "shares = 0");\n        _mint(msg.sender, shares);\n\n        _update(bal0, bal1);\n    }\n\n    function removeLiquidity(uint _shares)\n        external\n        returns (uint amount0, uint amount1)\n    {\n        /*\n        Claim\n        dx, dy = amount of liquidity to remove\n        dx = s / T * x\n        dy = s / T * y\n\n        Proof\n        Let\'s find dx, dy such that\n        v / L = s / T\n        \n        where\n        v = f(dx, dy) = sqrt(dxdy)\n        L = total liquidity = sqrt(xy)\n        s = shares\n        T = total supply\n\n        --- Equation 1 ---\n        v = s / T * L\n        sqrt(dxdy) = s / T * sqrt(xy)\n\n        Amount of liquidity to remove must not change price so \n        dx / dy = x / y\n\n        replace dy = dx * y / x\n        sqrt(dxdy) = sqrt(dx * dx * y / x) = dx * sqrt(y / x)\n\n        Divide both sides of Equation 1 with sqrt(y / x)\n        dx = s / T * sqrt(xy) / sqrt(y / x)\n           = s / T * sqrt(x^2) = s / T * x\n\n        Likewise\n        dy = s / T * y\n        */\n        amount0 = (_shares * reserve0) / totalSupply;\n        amount1 = (_shares * reserve1) / totalSupply;\n\n        _burn(msg.sender, _shares);\n        _update(reserve0 - amount0, reserve1 - amount1);\n\n        if (amount0 > 0) {\n            token0.transfer(msg.sender, amount0);\n        }\n        if (amount1 > 0) {\n            token1.transfer(msg.sender, amount1);\n        }\n    }\n\n    function _sqrt(uint y) private pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function _min(uint x, uint y) private pure returns (uint) {\n        return x <= y ? x : y;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address account) external view returns (uint);\n\n    function transfer(address recipient, uint amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint amount);\n    event Approval(address indexed owner, address indexed spender, uint amount);\n}\n\n')))}x.isMDXComponent=!0}}]);