"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[717],{3905:function(n,e,t){t.d(e,{Zo:function(){return l},kt:function(){return m}});var r=t(7294);function i(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function a(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function s(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?a(Object(t),!0).forEach((function(e){i(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function o(n,e){if(null==n)return{};var t,r,i=function(n,e){if(null==n)return{};var t,r,i={},a=Object.keys(n);for(r=0;r<a.length;r++)t=a[r],e.indexOf(t)>=0||(i[t]=n[t]);return i}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(r=0;r<a.length;r++)t=a[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(i[t]=n[t])}return i}var u=r.createContext({}),d=function(n){var e=r.useContext(u),t=e;return n&&(t="function"==typeof n?n(e):s(s({},e),n)),t},l=function(n){var e=d(n.components);return r.createElement(u.Provider,{value:e},n.children)},c={inlineCode:"code",wrapper:function(n){var e=n.children;return r.createElement(r.Fragment,{},e)}},p=r.forwardRef((function(n,e){var t=n.components,i=n.mdxType,a=n.originalType,u=n.parentName,l=o(n,["components","mdxType","originalType","parentName"]),p=d(t),m=i,f=p["".concat(u,".").concat(m)]||p[m]||c[m]||a;return t?r.createElement(f,s(s({ref:e},l),{},{components:t})):r.createElement(f,s({ref:e},l))}));function m(n,e){var t=arguments,i=e&&e.mdxType;if("string"==typeof n||i){var a=t.length,s=new Array(a);s[0]=p;var o={};for(var u in e)hasOwnProperty.call(e,u)&&(o[u]=e[u]);o.originalType=n,o.mdxType="string"==typeof n?n:i,s[1]=o;for(var d=2;d<a;d++)s[d]=t[d];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},1302:function(n,e,t){t.r(e),t.d(e,{contentTitle:function(){return u},default:function(){return p},frontMatter:function(){return o},metadata:function(){return d},toc:function(){return l}});var r=t(7462),i=t(3366),a=(t(7294),t(3905)),s=["components"],o={title:"Five",version:"0.8.6",description:"Five"},u=void 0,d={unversionedId:"Projects/Five",id:"Projects/Five",isDocsHomePage:!1,title:"Five",description:"Five",source:"@site/docs/Projects/Five.md",sourceDirName:"Projects",slug:"/Projects/Five",permalink:"/rooctblog/docs/Projects/Five",tags:[],version:"current",frontMatter:{title:"Five",version:"0.8.6",description:"Five"},sidebar:"tutorialSidebar",previous:{title:"BabyToken",permalink:"/rooctblog/docs/Projects/BabyToken"},next:{title:"MasterChef",permalink:"/rooctblog/docs/Projects/MasterChef"}},l=[],c={toc:l};function p(n){var e=n.components,t=(0,i.Z)(n,s);return(0,a.kt)("wrapper",(0,r.Z)({},c,t,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'/**\n *Submitted for verification at BscScan.com on 2022-02-16\n*/\n\npragma solidity ^0.8.6;\n\n// SPDX-License-Identifier: Unlicensed\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\'s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\'s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\nabstract contract Ownable {\n    address private _owner;\n    address private _previousOwner;\n    uint256 private _lockTime;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor ()  {\n        address msgSender = msg.sender;\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }   \n    \n    modifier onlyOwner() {\n        require(_owner == msg.sender, "Ownable: caller is not the owner");\n        _;\n    }\n    \n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\'s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\'s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, "SafeMath: subtraction overflow");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\'s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\'s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n        // benefit is lost if \'b\' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\'s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, "SafeMath: division by zero");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\'s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\'t hold\n\n        return c;\n    }\n}\n\ninterface IUniswapV2Factory {\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint256\n    );\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(address tokenA, address tokenB)\n        external\n        returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n}\n\ninterface IUniswapV2Pair {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to)\n        external\n        returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n\ncontract FiveToken is IERC20, Ownable {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) private _tOwned;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    mapping (address => bool) isDividendExempt;\n    mapping(address => bool) private _isExcludedFromFee;\n    mapping(address => bool) private _updated;\n    \n    uint256 private _tFeeTotal;\n    string private _name = "Five";\n    string private _symbol = "Five";\n    uint8 private _decimals = 9;\n\n    uint256 public _burnFee = 400;\n    uint256 private _previousburnFee;\n\n    uint256 public _lpFee = 200;\n    uint256 private _previousLpFee;\n\n    uint256 public _cakeFee = 0;\n    uint256 private _previousCakeFee;\n\n    uint256 public _inviterFee = 700;\n    uint256 private _previousInviterFee;\n\n    uint256 currentIndex;  \n    uint256 private _tTotal = 100 * 10**8 * 10**9;\n    uint256 distributorGas = 500000;\n    uint256 public minPeriod = 1 hours;\n    uint256 public lpFeeShareTime;\n\n    IUniswapV2Router02 public immutable uniswapV2Router;\n    address public immutable uniswapV2Pair;\n    address private fromAddress;\n    address private toAddress;\n\n    mapping(address => address) public inviter;\n    address[] shareholders;\n    mapping (address => uint256) shareholderIndexes;\n\n    bool inSwapAndLiquify;\n    \n    modifier lockTheSwap() {\n        inSwapAndLiquify = true;\n        _;\n        inSwapAndLiquify = false;\n    }\n    \n    constructor() {\n        _tOwned[msg.sender] = _tTotal;\n       \n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n\n        // Create a uniswap pair for this new token\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\n\n        // set the rest of the contract variables\n        uniswapV2Router = _uniswapV2Router;\n\n        //exclude owner and this contract from fee\n        _isExcludedFromFee[msg.sender] = true;\n        _isExcludedFromFee[address(this)] = true;\n        isDividendExempt[address(this)] = true;\n        isDividendExempt[address(0)] = true;\n        \n        emit Transfer(address(0), msg.sender, _tTotal);\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint256) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _tOwned[account];\n    }\n\n    function transfer(address recipient, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            msg.sender,\n            _allowances[sender][msg.sender].sub(\n                amount,\n                "ERC20: transfer amount exceeds allowance"\n            )\n        );\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender].add(addedValue)\n        );\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender].sub(\n                subtractedValue,\n                "ERC20: decreased allowance below zero"\n            )\n        );\n        return true;\n    }\n\n    function totalFees() public view returns (uint256) {\n        return _tFeeTotal;\n    }\n\n   function isExcludedFromFee(address account) public view returns (bool) {\n        return _isExcludedFromFee[account];\n    }\n    function excludeFromFee(address account) public onlyOwner {\n        _isExcludedFromFee[account] = true;\n    }\n\n    function includeInFee(address account) public onlyOwner {\n        _isExcludedFromFee[account] = false;\n    }\n\n    //to recieve ETH from uniswapV2Router when swaping\n    receive() external payable {}\n\n    function removeAllFee() private {\n        _previousburnFee = _burnFee;\n        _previousLpFee = _lpFee;\n        _previousCakeFee = _cakeFee;\n        _previousInviterFee = _inviterFee;\n\n        _burnFee = 0;\n        _lpFee = 0;\n        _inviterFee = 0;\n        _cakeFee = 0;\n    }\n\n    function restoreAllFee() private {\n        _burnFee = _previousburnFee;\n        _lpFee = _previousLpFee;\n        _inviterFee = _previousInviterFee;\n        _cakeFee = _previousCakeFee;\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) private {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        require(amount > 0, "Transfer amount must be greater than zero");\n\n        //indicates if fee should be deducted from transfer\n        bool takeFee = true;\n\n        //if any account belongs to _isExcludedFromFee account then remove the fee\n        if (_isExcludedFromFee[from] || _isExcludedFromFee[to] || to == uniswapV2Pair || from == address(uniswapV2Router)) {\n            takeFee = false;\n        }\n        \n        bool shouldSetInviter = balanceOf(to) == 0 && inviter[to] == address(0) && from != uniswapV2Pair;\n\n        //transfer amount, it will take tax, burn, liquidity fee\n        _tokenTransfer(from, to, amount, takeFee);\n        \n        if (shouldSetInviter) {\n            inviter[to] = from;\n        }\n        if(fromAddress == address(0) ) fromAddress = from;\n        if(toAddress == address(0)) toAddress = to;\n        if(!isDividendExempt[fromAddress] && fromAddress != uniswapV2Pair ) setShare(fromAddress);\n        if(!isDividendExempt[toAddress] && toAddress != uniswapV2Pair ) setShare(toAddress);\n        \n        fromAddress = from;\n        toAddress = to;  \n         if(_tOwned[address(this)] >= 1 * 10**4 * 10**9 && from !=address(this) && lpFeeShareTime.add(minPeriod) <= block.timestamp) {\n             process(distributorGas) ;\n             lpFeeShareTime = block.timestamp;\n        }\n    }\n    \n    function process(uint256 gas) private {\n        uint256 shareholderCount = shareholders.length;\n\n        if(shareholderCount == 0)return;\n        uint256 nowbanance = _tOwned[address(this)];\n        uint256 gasUsed = 0;\n        uint256 gasLeft = gasleft();\n\n        uint256 iterations = 0;\n\n        while(gasUsed < gas && iterations < shareholderCount) {\n            if(currentIndex >= shareholderCount){\n                currentIndex = 0;\n            }\n\n          uint256 amount = nowbanance.mul(IERC20(uniswapV2Pair).balanceOf(shareholders[currentIndex])).div(IERC20(uniswapV2Pair).totalSupply());\n         if( amount < 1 * 10**9) {\n             currentIndex++;\n             iterations++;\n             return;\n         }\n         if(_tOwned[address(this)]  < amount )return;\n            distributeDividend(shareholders[currentIndex],amount);\n            \n            gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\n            gasLeft = gasleft();\n            currentIndex++;\n            iterations++;\n        }\n    }\n   \n    function distributeDividend(address shareholder ,uint256 amount) internal {\n            _tOwned[address(this)] = _tOwned[address(this)].sub(amount);\n            _tOwned[shareholder] = _tOwned[shareholder].add(amount);\n             emit Transfer(address(this), shareholder, amount);\n    }\n\n    function setShare(address shareholder) private {\n           if(_updated[shareholder] ){      \n                if(IERC20(uniswapV2Pair).balanceOf(shareholder) == 0) quitShare(shareholder);              \n                return;  \n           }\n           if(IERC20(uniswapV2Pair).balanceOf(shareholder) == 0) return;  \n            addShareholder(shareholder);\n            _updated[shareholder] = true;   \n    }\n\n    function addShareholder(address shareholder) internal {\n        shareholderIndexes[shareholder] = shareholders.length;\n        shareholders.push(shareholder);\n    }\n    \n    function quitShare(address shareholder) private {\n           removeShareholder(shareholder);   \n           _updated[shareholder] = false; \n    }\n\n    function removeShareholder(address shareholder) internal {\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1];\n        shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];\n        shareholders.pop();\n    }\n\n    //this method is responsible for taking all fee, if takeFee is true\n    function _tokenTransfer(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bool takeFee\n    ) private {\n        if (!takeFee) removeAllFee();\n        _transferStandard(sender, recipient, amount);\n        if (!takeFee) restoreAllFee();\n    }\n\n    //\n    function _takeburnFee(\n        address sender,\n        uint256 tAmount\n    ) private {\n        if (_burnFee == 0) return;\n        if(_tFeeTotal >= 999 * 10**7 * 10**9)_burnFee = 0;\n        _tOwned[address(0)] = _tOwned[address(0)].add(tAmount);\n        _tFeeTotal = _tFeeTotal.add(tAmount);\n        emit Transfer(sender, address(0), tAmount);\n    }\n\n    function _takeLPFee(address sender,uint256 tAmount) private {\n        if (_lpFee == 0 && _cakeFee == 0) return;\n        _tOwned[address(this)] = _tOwned[address(this)].add(tAmount);\n        emit Transfer(sender, address(this), tAmount);\n    }\n\n    function _takeInviterFee(\n        address sender,\n        address recipient,\n        uint256 tAmount\n    ) private {\n        if (_inviterFee == 0) return;\n        address cur;\n        if (sender == uniswapV2Pair) {\n            cur = recipient;\n        } else if (recipient == uniswapV2Pair) {\n            cur = sender;\n        } else {\n            _tOwned[address(this)] = _tOwned[address(this)].add(tAmount.div(10000).mul(_inviterFee));\n            emit Transfer(sender, address(this), tAmount.div(10000).mul(_inviterFee));\n            return;\n        }\n\n        uint256 accurRate;\n        for (int256 i = 0; i < 8; i++) {\n            uint256 rate;\n            if (i == 0) {\n                rate = 250;\n            } else if(i == 1 ){\n                rate = 150;\n            } else {\n                rate = 50;\n            }\n            cur = inviter[cur];\n            if (cur == address(0)) {\n                break;\n            }\n            accurRate = accurRate.add(rate);\n\n            uint256 curTAmount = tAmount.div(10000).mul(rate);\n            _tOwned[cur] = _tOwned[cur].add(curTAmount);\n            emit Transfer(sender, cur, curTAmount);\n        }\n        \n        _tOwned[address(this)] = _tOwned[address(this)].add(tAmount.div(10000).mul(_inviterFee.sub(accurRate)));\n        emit Transfer(sender, address(this), tAmount.div(10000).mul(_inviterFee.sub(accurRate)));\n    }\n\n    function _transferStandard(\n        address sender,\n        address recipient,\n        uint256 tAmount\n    ) private {\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _takeburnFee(sender, tAmount.div(10000).mul(_burnFee));\n        _takeLPFee(sender, tAmount.div(10000).mul(_lpFee.add(_cakeFee)));\n        _takeInviterFee(sender, recipient, tAmount);\n       \n        uint256 recipientRate = 10000 - _burnFee -_lpFee - _cakeFee - _inviterFee;\n        _tOwned[recipient] = _tOwned[recipient].add(tAmount.div(10000).mul(recipientRate));\n        emit Transfer(sender, recipient, tAmount.div(10000).mul(recipientRate));\n    }\n\n}\n\n')))}p.isMDXComponent=!0}}]);