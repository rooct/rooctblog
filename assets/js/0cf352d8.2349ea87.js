"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7582],{3905:function(n,e,u){u.d(e,{Zo:function(){return d},kt:function(){return m}});var r=u(7294);function i(n,e,u){return e in n?Object.defineProperty(n,e,{value:u,enumerable:!0,configurable:!0,writable:!0}):n[e]=u,n}function s(n,e){var u=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),u.push.apply(u,r)}return u}function t(n){for(var e=1;e<arguments.length;e++){var u=null!=arguments[e]?arguments[e]:{};e%2?s(Object(u),!0).forEach((function(e){i(n,e,u[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(u)):s(Object(u)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(u,e))}))}return n}function o(n,e){if(null==n)return{};var u,r,i=function(n,e){if(null==n)return{};var u,r,i={},s=Object.keys(n);for(r=0;r<s.length;r++)u=s[r],e.indexOf(u)>=0||(i[u]=n[u]);return i}(n,e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);for(r=0;r<s.length;r++)u=s[r],e.indexOf(u)>=0||Object.prototype.propertyIsEnumerable.call(n,u)&&(i[u]=n[u])}return i}var a=r.createContext({}),f=function(n){var e=r.useContext(a),u=e;return n&&(u="function"==typeof n?n(e):t(t({},e),n)),u},d=function(n){var e=f(n.components);return r.createElement(a.Provider,{value:e},n.children)},g={inlineCode:"code",wrapper:function(n){var e=n.children;return r.createElement(r.Fragment,{},e)}},c=r.forwardRef((function(n,e){var u=n.components,i=n.mdxType,s=n.originalType,a=n.parentName,d=o(n,["components","mdxType","originalType","parentName"]),c=f(u),m=i,l=c["".concat(a,".").concat(m)]||c[m]||g[m]||s;return u?r.createElement(l,t(t({ref:e},d),{},{components:u})):r.createElement(l,t({ref:e},d))}));function m(n,e){var u=arguments,i=e&&e.mdxType;if("string"==typeof n||i){var s=u.length,t=new Array(s);t[0]=c;var o={};for(var a in e)hasOwnProperty.call(e,a)&&(o[a]=e[a]);o.originalType=n,o.mdxType="string"==typeof n?n:i,t[1]=o;for(var f=2;f<s;f++)t[f]=u[f];return r.createElement.apply(null,t)}return r.createElement.apply(null,u)}c.displayName="MDXCreateElement"},3637:function(n,e,u){u.r(e),u.d(e,{contentTitle:function(){return a},default:function(){return c},frontMatter:function(){return o},metadata:function(){return f},toc:function(){return d}});var r=u(7462),i=u(3366),s=(u(7294),u(3905)),t=["components"],o={title:"\u4f17\u7b79"},a=void 0,f={unversionedId:"solidity/projects/CrowdingFund",id:"solidity/projects/CrowdingFund",isDocsHomePage:!1,title:"\u4f17\u7b79",description:"`",source:"@site/docs/solidity/projects/CrowdingFund.md",sourceDirName:"solidity/projects",slug:"/solidity/projects/CrowdingFund",permalink:"/rooctblog/docs/solidity/projects/CrowdingFund",tags:[],version:"current",frontMatter:{title:"\u4f17\u7b79"}},d=[],g={toc:d};function c(n){var e=n.components,u=(0,i.Z)(n,t);return(0,s.kt)("wrapper",(0,r.Z)({},g,u,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\ncontract CrowdFunding {\n  \n  // \u6295\u8d44\u4eba\u7ed3\u6784\u5b9a\u4e49\n  struct Funder {\n    address payable addr;   // \u6295\u8d44\u4eba\u7684\u5730\u5740\n    uint amount;            // \u51fa\u8d44\u6570\u989d\n  }\n\n  // \u8d44\u91d1\u4f7f\u7528\u8bf7\u6c42\u7ed3\u6784\u5b9a\u4e49\n  struct Use {\n    string info;                     // \u4f7f\u7528\u8bf7\u6c42\u7684\u8bf4\u660e\n    uint goal;                       // \u4f7f\u7528\u8bf7\u6c42\u7684\u6570\u989d\n    uint agreeAmount;                // \u76ee\u524d\u7684\u540c\u610f\u6570\u989d\n    uint disagree;                   // \u76ee\u524d\u7684\u4e0d\u540c\u610f\u6570\u989d\n    bool over;                       // \u8bf7\u6c42\u662f\u5426\u7ed3\u675f\n    mapping(uint => uint) agree;     // \u51fa\u8d44\u4eba\u662f\u5426\u540c\u610f 0: \u8fd8\u6ca1\u51b3\u5b9a\uff0c1\uff1a\u540c\u610f\uff0c2\uff1a\u4e0d\u540c\u610f\n  }\n\n  // \u4f17\u7b79\u9879\u76ee\u7684\u7ed3\u6784\u5b9a\u4e49\n  struct Funding {\n    address payable initiator;       // \u53d1\u8d77\u4eba\n    string title;                    // \u9879\u76ee\u6807\u9898\n    string info;                     // \u9879\u76ee\u7b80\u4ecb\n    uint goal;                       // \u76ee\u6807\u91d1\u989d\n    uint endTime;                    // \u4f17\u7b79\u7ed3\u675f\u65f6\u95f4\n\n    bool success;                    // \u4f17\u7b79\u662f\u5426\u6210\u529f\uff0c\u6210\u529f\u5219 amount \u542b\u4e49\u4e3a\u9879\u76ee\u5269\u4f59\u7684\u94b1\n\n    uint amount;                     // \u5f53\u524d\u5df2\u7ecf\u7b79\u96c6\u5230\u7684\u91d1\u989d\n    uint numFunders;                 // \u6295\u8d44\u8bb0\u5f55\u6570\u91cf\n    uint numUses;                    // \u4f7f\u7528\u8bf7\u6c42\u6570\u91cf\n    mapping(uint => Funder) funders; // \u6295\u8d44\u8bb0\u5f55\u5177\u4f53\u4fe1\u606f\n    mapping(uint => Use) uses;       // \u6240\u6709\u7684\u4f7f\u7528\u8bf7\u6c42\n  }\n\n  uint public numFundings;                  // \u4f17\u7b79\u9879\u76ee\u6570\u91cf\n  mapping(uint => Funding) public fundings; // \u6240\u6709\u7684\u4f17\u7b79\u9879\u76ee\n\n  /**\n   * \u53d1\u8d77\u4f17\u7b79\u9879\u76ee\n   * @param initiator \u53d1\u8d77\u4eba\n   * @param title \u9879\u76ee\u6807\u9898\n   * @param info \u9879\u76ee\u7b80\u4ecb\n   * @param goal \u76ee\u6807\u91d1\u989d\n   * @param endTime \u7ed3\u675f\u65f6\u95f4\n   */\n  function newFunding(address payable initiator, string memory title, string memory info, uint goal, uint endTime) public returns(uint) {\n    require(endTime > block.timestamp);\n\n    numFundings = numFundings + 1;\n    Funding storage f = fundings[numFundings];\n    f.initiator = initiator;\n    f.title = title;\n    f.info = info;\n    f.goal = goal;\n    f.endTime = endTime;\n    f.success = false;\n    f.amount = 0;\n    f.numFunders = 0;\n    f.numUses = 0;\n    \n    return numFundings;\n  }\n\n  function contribute(uint ID) public payable {\n    // \u8d21\u732e\u7684\u94b1\u5fc5\u987b\u5927\u4e8e0\uff0c\u4e0d\u80fd\u8d85\u8fc7\u5dee\u989d\n    require(msg.value > 0 && msg.value <= fundings[ID].goal - fundings[ID].amount);\n    // \u65f6\u95f4\u4e0a\u5fc5\u987b\u8fd8\u6ca1\u7ed3\u675f\n    require(fundings[ID].endTime > block.timestamp);\n    // \u5fc5\u987b\u662f\u672a\u5b8c\u6210\u7684\u4f17\u7b79\n    require(fundings[ID].success == false);\n\n    Funding storage f = fundings[ID];\n    f.amount += msg.value;\n    f.numFunders = f.numFunders + 1;\n    f.funders[f.numFunders].addr = msg.sender;\n    f.funders[f.numFunders].amount = msg.value;\n    // \u8003\u8651\u672c\u9879\u76ee\u662f\u5426\u8fbe\u6210\u76ee\u6807\n    f.success = f.amount >= f.goal;\n  }\n\n  // \u9000\u94b1\n  function returnMoney(uint ID) public {\n    require(ID <= numFundings && ID >= 1);\n    require(fundings[ID].success == false);\n\n    Funding storage f = fundings[ID];\n    for(uint i=1; i<=f.numFunders; i++)\n      if(f.funders[i].addr == msg.sender) {\n        f.funders[i].addr.transfer(f.funders[i].amount);\n        f.funders[i].amount = 0;\n        f.amount -= f.funders[i].amount;\n      }\n  }\n\n  function newUse(uint ID, uint goal, string memory info) public {\n    require(ID <= numFundings && ID >= 1);\n    require(fundings[ID].success == true);\n    require(goal <= fundings[ID].amount);\n    require(msg.sender == fundings[ID].initiator);\n\n    Funding storage f = fundings[ID];\n    f.numUses = f.numUses + 1;\n    f.uses[f.numUses].info = info;\n    f.uses[f.numUses].goal = goal;\n    f.uses[f.numUses].agreeAmount = 0;\n    f.uses[f.numUses].disagree = 0;\n    f.uses[f.numUses].over = false;\n    f.amount = f.amount - goal;\n  }\n\n  function agreeUse(uint ID, uint useID, bool agree) public {\n    require(ID <= numFundings && ID >= 1);\n    require(useID <= fundings[ID].numUses && useID >= 1);\n    require(fundings[ID].uses[useID].over == false);\n\n    for(uint i=1; i<=fundings[ID].numFunders; i++)\n      if(fundings[ID].funders[i].addr == msg.sender) {\n        if(fundings[ID].uses[useID].agree[i] == 1) {\n          fundings[ID].uses[useID].agreeAmount -= fundings[ID].funders[i].amount;\n        } else if(fundings[ID].uses[useID].agree[i] == 2) {\n          fundings[ID].uses[useID].disagree -= fundings[ID].funders[i].amount;\n        }\n        if(agree) {\n          fundings[ID].uses[useID].agreeAmount += fundings[ID].funders[i].amount;\n          fundings[ID].uses[useID].agree[i] = 1;\n        }\n        else {\n          fundings[ID].uses[useID].disagree += fundings[ID].funders[i].amount;\n          fundings[ID].uses[useID].agree[i] = 2;\n        }\n      }\n    checkUse(ID, useID);\n  }\n\n  function checkUse(uint ID, uint useID) public {\n    require(ID <= numFundings && ID >= 1);\n    require(fundings[ID].uses[useID].over == false);\n\n    if(fundings[ID].uses[useID].agreeAmount >= fundings[ID].goal / 2) {\n      fundings[ID].uses[useID].over = true;\n      fundings[ID].initiator.transfer(fundings[ID].uses[useID].goal);\n    }\n    if(fundings[ID].uses[useID].disagree > fundings[ID].goal / 2) {\n      fundings[ID].amount = fundings[ID].amount + fundings[ID].uses[useID].goal;\n      fundings[ID].uses[useID].over = true;\n    }\n  }\n\n  function getUseLength(uint ID) public view returns (uint) {\n    require(ID <= numFundings && ID >= 1);\n\n    return fundings[ID].numUses;\n  }\n\n  function getUse(uint ID, uint useID, address addr) public view returns (string memory, uint, uint, uint, bool, uint) {\n    require(ID <= numFundings && ID >= 1);\n    require(useID <= fundings[ID].numUses && useID >= 1);\n\n    Use storage u = fundings[ID].uses[useID];\n    uint agree = 0;\n    for(uint i=1; i<=fundings[ID].numFunders; i++)\n      if(fundings[ID].funders[i].addr == addr) {\n        agree = fundings[ID].uses[useID].agree[i];\n        break;\n      }\n    return (u.info, u.goal, u.agreeAmount, u.disagree, u.over, agree);\n  }\n\n  function getBalance() public view returns (uint) {\n    return address(this).balance;\n  }\n  \n  function getMyFundings(address addr, uint ID) public view returns (uint) {\n      uint res = 0;\n      for(uint i=1; i<=fundings[ID].numFunders; i++) {\n          if(fundings[ID].funders[i].addr == addr)\n            res += fundings[ID].funders[i].amount;\n      }\n      return res;\n  } \n}\n")))}c.isMDXComponent=!0}}]);