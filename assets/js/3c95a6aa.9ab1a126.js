"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2345],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return m}});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=r.createContext({}),p=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=p(e.components);return r.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(t),m=o,f=d["".concat(s,".").concat(m)]||d[m]||u[m]||a;return t?r.createElement(f,i(i({ref:n},c),{},{components:t})):r.createElement(f,i({ref:n},c))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var p=2;p<a;p++)i[p]=t[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},7489:function(e,n,t){t.r(n),t.d(n,{contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return c}});var r=t(7462),o=t(3366),a=(t(7294),t(3905)),i=["components"],l={title:"ERC20",version:"0.8.10",description:"Example of ERC20 token in Solidity"},s=void 0,p={unversionedId:"Example/app/Erc20",id:"Example/app/Erc20",isDocsHomePage:!1,title:"ERC20",description:"Example of ERC20 token in Solidity",source:"@site/docs/Example/app/Erc20.md",sourceDirName:"Example/app",slug:"/Example/app/Erc20",permalink:"/rooctblog/docs/Example/app/Erc20",tags:[],version:"current",frontMatter:{title:"ERC20",version:"0.8.10",description:"Example of ERC20 token in Solidity"},sidebar:"tutorialSidebar",previous:{title:"English Auction",permalink:"/rooctblog/docs/Example/app/EnglishAuction"},next:{title:"ERC721",permalink:"/rooctblog/docs/Example/app/Erc721"}},c=[{value:"Here is the interface for ERC20.",id:"here-is-the-interface-for-erc20",children:[]},{value:"Example of <code>ERC20</code> token contract.",id:"example-of-erc20-token-contract",children:[]},{value:"Create your own ERC20 token",id:"create-your-own-erc20-token",children:[{value:"Here is an example",id:"here-is-an-example",children:[]},{value:"Contract to swap tokens",id:"contract-to-swap-tokens",children:[]}]}],u={toc:c};function d(e){var n=e.components,t=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Any contract that follow the ",(0,a.kt)("a",{href:"https://eips.ethereum.org/EIPS/eip-20",target:"__blank"},"ERC20 standard")," is a ERC20 token."),(0,a.kt)("p",null,"ERC20 tokens provide functionalities to"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"transfer tokens"),(0,a.kt)("li",{parentName:"ul"},"allow others to transfer tokens on behalf of the token holder")),(0,a.kt)("h3",{id:"here-is-the-interface-for-erc20"},"Here is the interface for ERC20."),(0,a.kt)("p",null,"@import IERC20 from './IERC20.sol'"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.0.0/contracts/token/ERC20/IERC20.sol\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address account) external view returns (uint);\n\n    function transfer(address recipient, uint amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n")),(0,a.kt)("h3",{id:"example-of-erc20-token-contract"},"Example of ",(0,a.kt)("inlineCode",{parentName:"h3"},"ERC20")," token contract."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport "./IERC20.sol";\n\ncontract ERC20 is IERC20 {\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n    string public name = "Solidity by Example";\n    string public symbol = "SOLBYEX";\n    uint8 public decimals = 18;\n\n    function transfer(address recipient, uint amount) external returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external returns (bool) {\n        allowance[sender][msg.sender] -= amount;\n        balanceOf[sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function mint(uint amount) external {\n        balanceOf[msg.sender] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), msg.sender, amount);\n    }\n\n    function burn(uint amount) external {\n        balanceOf[msg.sender] -= amount;\n        totalSupply -= amount;\n        emit Transfer(msg.sender, address(0), amount);\n    }\n}\n\n')),(0,a.kt)("h2",{id:"create-your-own-erc20-token"},"Create your own ERC20 token"),(0,a.kt)("p",null,"Using ",(0,a.kt)("a",{href:"https://github.com/OpenZeppelin/openzeppelin-contracts",target:"__blank"},"Open Zeppelin")," it's really easy to create your own ERC20 token."),(0,a.kt)("h3",{id:"here-is-an-example"},"Here is an example"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.0.0/contracts/token/ERC20/ERC20.sol";\n\ncontract MyToken is ERC20 {\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n        // Mint 100 tokens to msg.sender\n        // Similar to how\n        // 1 dollar = 100 cents\n        // 1 token = 1 * (10 ** decimals)\n        _mint(msg.sender, 100 * 10**uint(decimals()));\n    }\n}\n\n')),(0,a.kt)("h3",{id:"contract-to-swap-tokens"},"Contract to swap tokens"),(0,a.kt)("p",null,"Here is an example contract, ",(0,a.kt)("inlineCode",{parentName:"p"},"TokenSwap"),", to trade one ERC20 token for another."),(0,a.kt)("p",null,"This contract will swap tokens by calling"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"transferFrom(address sender, address recipient, uint256 amount)\n\n")),(0,a.kt)("p",null,"which will transfer ",(0,a.kt)("inlineCode",{parentName:"p"},"amount")," of token from ",(0,a.kt)("inlineCode",{parentName:"p"},"sender")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"recipient"),"."),(0,a.kt)("p",null,"For ",(0,a.kt)("inlineCode",{parentName:"p"},"transferFrom")," to succeed, ",(0,a.kt)("inlineCode",{parentName:"p"},"sender")," must"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"have more than ",(0,a.kt)("inlineCode",{parentName:"li"},"amount")," tokens in their balance"),(0,a.kt)("li",{parentName:"ul"},"allowed ",(0,a.kt)("inlineCode",{parentName:"li"},"TokenSwap")," to withdraw ",(0,a.kt)("inlineCode",{parentName:"li"},"amount")," tokens by calling ",(0,a.kt)("inlineCode",{parentName:"li"},"approve"))),(0,a.kt)("p",null,"prior to ",(0,a.kt)("inlineCode",{parentName:"p"},"TokenSwap")," calling ",(0,a.kt)("inlineCode",{parentName:"p"},"transferFrom")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.0.0/contracts/token/ERC20/IERC20.sol";\n\n/*\nHow to swap tokens\n\n1. Alice has 100 tokens from AliceCoin, which is a ERC20 token.\n2. Bob has 100 tokens from BobCoin, which is also a ERC20 token.\n3. Alice and Bob wants to trade 10 AliceCoin for 20 BobCoin.\n4. Alice or Bob deploys TokenSwap\n5. Alice approves TokenSwap to withdraw 10 tokens from AliceCoin\n6. Bob approves TokenSwap to withdraw 20 tokens from BobCoin\n7. Alice or Bob calls TokenSwap.swap()\n8. Alice and Bob traded tokens successfully.\n*/\n\ncontract TokenSwap {\n    IERC20 public token1;\n    address public owner1;\n    uint public amount1;\n    IERC20 public token2;\n    address public owner2;\n    uint public amount2;\n\n    constructor(\n        address _token1,\n        address _owner1,\n        uint _amount1,\n        address _token2,\n        address _owner2,\n        uint _amount2\n    ) {\n        token1 = IERC20(_token1);\n        owner1 = _owner1;\n        amount1 = _amount1;\n        token2 = IERC20(_token2);\n        owner2 = _owner2;\n        amount2 = _amount2;\n    }\n\n    function swap() public {\n        require(msg.sender == owner1 || msg.sender == owner2, "Not authorized");\n        require(\n            token1.allowance(owner1, address(this)) >= amount1,\n            "Token 1 allowance too low"\n        );\n        require(\n            token2.allowance(owner2, address(this)) >= amount2,\n            "Token 2 allowance too low"\n        );\n\n        _safeTransferFrom(token1, owner1, owner2, amount1);\n        _safeTransferFrom(token2, owner2, owner1, amount2);\n    }\n\n    function _safeTransferFrom(\n        IERC20 token,\n        address sender,\n        address recipient,\n        uint amount\n    ) private {\n        bool sent = token.transferFrom(sender, recipient, amount);\n        require(sent, "Token transfer failed");\n    }\n}\n\n')))}d.isMDXComponent=!0}}]);