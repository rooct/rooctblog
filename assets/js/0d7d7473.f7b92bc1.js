"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3071],{3905:function(e,r,n){n.d(r,{Zo:function(){return d},kt:function(){return p}});var t=n(7294);function o(e,r,n){return r in e?Object.defineProperty(e,r,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[r]=n,e}function i(e,r){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);r&&(t=t.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),n.push.apply(n,t)}return n}function a(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?i(Object(n),!0).forEach((function(r){o(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(n,r))}))}return e}function s(e,r){if(null==e)return{};var n,t,o=function(e,r){if(null==e)return{};var n,t,o={},i=Object.keys(e);for(t=0;t<i.length;t++)n=i[t],r.indexOf(n)>=0||(o[n]=e[n]);return o}(e,r);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)n=i[t],r.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=t.createContext({}),c=function(e){var r=t.useContext(l),n=r;return e&&(n="function"==typeof e?e(r):a(a({},r),e)),n},d=function(e){var r=c(e.components);return t.createElement(l.Provider,{value:r},e.children)},u={inlineCode:"code",wrapper:function(e){var r=e.children;return t.createElement(t.Fragment,{},r)}},m=t.forwardRef((function(e,r){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=c(n),p=o,f=m["".concat(l,".").concat(p)]||m[p]||u[p]||i;return n?t.createElement(f,a(a({ref:r},d),{},{components:n})):t.createElement(f,a({ref:r},d))}));function p(e,r){var n=arguments,o=r&&r.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=m;var s={};for(var l in r)hasOwnProperty.call(r,l)&&(s[l]=r[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var c=2;c<i;c++)a[c]=n[c];return t.createElement.apply(null,a)}return t.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9949:function(e,r,n){n.r(r),n.d(r,{contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return d}});var t=n(7462),o=n(3366),i=(n(7294),n(3905)),a=["components"],s={},l="CSV",c={unversionedId:"rusty/encoding/csv",id:"rusty/encoding/csv",isDocsHomePage:!1,title:"CSV",description:"\u8bfb\u53d6 CSV \u8bb0\u5f55",source:"@site/docs/rusty/encoding/csv.md",sourceDirName:"rusty/encoding",slug:"/rusty/encoding/csv",permalink:"/rooctblog/docs/rusty/encoding/csv",tags:[],version:"current",frontMatter:{},sidebar:"rust",previous:{title:"\u7248\u672c\u53f7",permalink:"/rooctblog/docs/rusty/devtools/version"},next:{title:"\u7f16\u89e3\u7801",permalink:"/rooctblog/docs/rusty/encoding/intro"}},d=[{value:"\u8bfb\u53d6 CSV \u8bb0\u5f55",id:"\u8bfb\u53d6-csv-\u8bb0\u5f55",children:[{value:"\u8bfb\u53d6\u4f7f\u7528\u4e86\u4e0d\u540c\u5206\u9694\u7b26\u7684 CSV \u8bb0\u5f55",id:"\u8bfb\u53d6\u4f7f\u7528\u4e86\u4e0d\u540c\u5206\u9694\u7b26\u7684-csv-\u8bb0\u5f55",children:[]},{value:"\u57fa\u4e8e\u7ed9\u5b9a\u6761\u4ef6\u6765\u8fc7\u6ee4 CSV \u8bb0\u5f55",id:"\u57fa\u4e8e\u7ed9\u5b9a\u6761\u4ef6\u6765\u8fc7\u6ee4-csv-\u8bb0\u5f55",children:[]},{value:"\u5e8f\u5217\u5316\u4e3a CSV",id:"\u5e8f\u5217\u5316\u4e3a-csv",children:[]},{value:"\u4f7f\u7528 serde \u5e8f\u5217\u5316\u4e3a CSV",id:"\u4f7f\u7528-serde-\u5e8f\u5217\u5316\u4e3a-csv",children:[]},{value:"CSV \u5217\u8f6c\u6362",id:"csv-\u5217\u8f6c\u6362",children:[]}]}],u={toc:d};function m(e){var r=e.components,n=(0,o.Z)(e,a);return(0,i.kt)("wrapper",(0,t.Z)({},u,n,{components:r,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"csv"},"CSV"),(0,i.kt)("h2",{id:"\u8bfb\u53d6-csv-\u8bb0\u5f55"},"\u8bfb\u53d6 CSV \u8bb0\u5f55"),(0,i.kt)("p",null,"\u6211\u4eec\u53ef\u4ee5\u5c06\u6807\u51c6\u7684 CSV \u8bb0\u5f55\u503c\u8bfb\u53d6\u5230 ",(0,i.kt)("a",{parentName:"p",href:"https://docs.rs/csv/*/csv/struct.StringRecord.html"},"csv::StringRecord")," \u4e2d\uff0c\u4f46\u662f\u8be5\u6570\u636e\u7ed3\u6784\u671f\u5f85\u5408\u6cd5\u7684 UTF8 \u6570\u636e\u884c\uff0c\u4f60\u8fd8\u53ef\u4ee5\u4f7f\u7528 ",(0,i.kt)("a",{parentName:"p",href:"https://docs.rs/csv/1.1.6/csv/struct.ByteRecord.html"},"csv::ByteRecord")," \u6765\u8bfb\u53d6\u975e UTF8 \u6570\u636e\u3002"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust,editable"},'use csv::Error;\n\nfn main -> Result<, Error> {\n    let csv = "year,make,model,description\n        1948,Porsche,356,Luxury sports car\n        1967,Ford,Mustang fastback 1967,American car";\n\n    let mut reader = csv::Reader::from_reader(csv.as_bytes);\n    for record in reader.records {\n        let record = record?;\n        println!(\n            "In {}, {} built the {} model. It is a {}.",\n            &record[0],\n            &record[1],\n            &record[2],\n            &record[3]\n        );\n    }\n\n    Ok()\n}\n')),(0,i.kt)("p",null,"\u8fd8\u53ef\u4ee5\u4f7f\u7528 ",(0,i.kt)("a",{parentName:"p",href:"https://docs.rs/serde/1.0.136/serde/"},(0,i.kt)("inlineCode",{parentName:"a"},"serde"))," \u5c06\u6570\u636e\u53cd\u5e8f\u5217\u5316\u6210\u4e00\u4e2a\u5f3a\u7c7b\u578b\u7684\u7ed3\u6784\u4f53\u3002"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust,editable"},'use serde::Deserialize;\n#[derive(Deserialize)]\nstruct Record {\n    year: u16,\n    make: String,\n    model: String,\n    description: String,\n}\n\nfn main -> Result<, csv::Error> {\n    let csv = "year,make,model,description\n1948,Porsche,356,Luxury sports car\n1967,Ford,Mustang fastback 1967,American car";\n\n    let mut reader = csv::Reader::from_reader(csv.as_bytes);\n\n    for record in reader.deserialize {\n        let record: Record = record?;\n        println!(\n            "In {}, {} built the {} model. It is a {}.",\n            record.year,\n            record.make,\n            record.model,\n            record.description\n        );\n    }\n\n    Ok()\n}\n')),(0,i.kt)("h3",{id:"\u8bfb\u53d6\u4f7f\u7528\u4e86\u4e0d\u540c\u5206\u9694\u7b26\u7684-csv-\u8bb0\u5f55"},"\u8bfb\u53d6\u4f7f\u7528\u4e86\u4e0d\u540c\u5206\u9694\u7b26\u7684 CSV \u8bb0\u5f55"),(0,i.kt)("p",null,"\u4e0b\u9762\u7684\u4f8b\u5b50\u5c06\u8bfb\u53d6\u4f7f\u7528\u4e86 ",(0,i.kt)("inlineCode",{parentName:"p"},"tab")," \u4f5c\u4e3a\u5206\u9694\u7b26\u7684 CSV \u8bb0\u5f55\u3002"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust,editable"},'use csv::Error;\nuse serde::Deserialize;\n#[derive(Debug, Deserialize)]\nstruct Record {\n    name: String,\n    place: String,\n    #[serde(deserialize_with = "csv::invalid_option")]\n    id: Option<u64>,\n}\n\nuse csv::ReaderBuilder;\n\nfn main -> Result<, Error> {\n    let data = "name\\tplace\\tid\n        Mark\\tMelbourne\\t46\n        Ashley\\tZurich\\t92";\n\n    let mut reader = ReaderBuilder::new.delimiter(b\'\\t\').from_reader(data.as_bytes);\n    for result in reader.deserialize::<Record> {\n        println!("{:?}", result?);\n    }\n\n    Ok()\n}\n')),(0,i.kt)("h3",{id:"\u57fa\u4e8e\u7ed9\u5b9a\u6761\u4ef6\u6765\u8fc7\u6ee4-csv-\u8bb0\u5f55"},"\u57fa\u4e8e\u7ed9\u5b9a\u6761\u4ef6\u6765\u8fc7\u6ee4 CSV \u8bb0\u5f55"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust,editable"},'use error_chain::error_chain;\n\nuse std::io;\n\nerror_chain!{\n    foreign_links {\n        Io(std::io::Error);\n        CsvError(csv::Error);\n    }\n}\n\nfn main -> Result<> {\n    let query = "CA";\n    let data = "\\\nCity,State,Population,Latitude,Longitude\nKenai,AK,7610,60.5544444,-151.2583333\nOakman,AL,,33.7133333,-87.3886111\nSandfort,AL,,32.3380556,-85.2233333\nWest Hollywood,CA,37031,34.0900000,-118.3608333";\n\n    let mut rdr = csv::ReaderBuilder::new.from_reader(data.as_bytes);\n    let mut wtr = csv::Writer::from_writer(io::stdout);\n\n    wtr.write_record(rdr.headers?)?;\n\n    for result in rdr.records {\n        let record = result?;\n        if record.iter.any(|field| field == query) {\n            wtr.write_record(&record)?;\n        }\n    }\n\n    wtr.flush?;\n    Ok()\n}\n')),(0,i.kt)("h3",{id:"\u5e8f\u5217\u5316\u4e3a-csv"},"\u5e8f\u5217\u5316\u4e3a CSV"),(0,i.kt)("p",null,"\u4e0b\u9762\u4f8b\u5b50\u5c55\u793a\u4e86\u5982\u4f55\u5c06 Rust \u7c7b\u578b\u5e8f\u5217\u5316\u4e3a CSV\u3002"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust,editable"},'use std::io;\n\nfn main -> Result<> {\n    let mut wtr = csv::Writer::from_writer(io::stdout);\n\n    wtr.write_record(&["Name", "Place", "ID"])?;\n\n    wtr.serialize(("Mark", "Sydney", 87))?;\n    wtr.serialize(("Ashley", "Dublin", 32))?;\n    wtr.serialize(("Akshat", "Delhi", 11))?;\n\n    wtr.flush?;\n    Ok()\n}\n')),(0,i.kt)("h3",{id:"\u4f7f\u7528-serde-\u5e8f\u5217\u5316\u4e3a-csv"},"\u4f7f\u7528 serde \u5e8f\u5217\u5316\u4e3a CSV"),(0,i.kt)("p",null,"\u4e0b\u9762\u4f8b\u5b50\u5c06\u81ea\u5b9a\u4e49\u6570\u636e\u7ed3\u6784\u901a\u8fc7 ",(0,i.kt)("inlineCode",{parentName:"p"},"serde")," \u5e8f\u5217\u5316 CSV\u3002"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust,editable"},'use error_chain::error_chain;\nuse serde::Serialize;\nuse std::io;\n\nerror_chain! {\n   foreign_links {\n       IOError(std::io::Error);\n       CSVError(csv::Error);\n   }\n}\n\n#[derive(Serialize)]\nstruct Record<\'a> {\n    name: &\'a str,\n    place: &\'a str,\n    id: u64,\n}\n\nfn main -> Result<> {\n    let mut wtr = csv::Writer::from_writer(io::stdout);\n\n    let rec1 = Record { name: "Mark", place: "Melbourne", id: 56};\n    let rec2 = Record { name: "Ashley", place: "Sydney", id: 64};\n    let rec3 = Record { name: "Akshat", place: "Delhi", id: 98};\n\n    wtr.serialize(rec1)?;\n    wtr.serialize(rec2)?;\n    wtr.serialize(rec3)?;\n\n    wtr.flush?;\n\n    Ok()\n}\n')),(0,i.kt)("h3",{id:"csv-\u5217\u8f6c\u6362"},"CSV \u5217\u8f6c\u6362"),(0,i.kt)("p",null,"\u4e0b\u9762\u4ee3\u7801\u5c06\u5305\u542b\u6709\u989c\u8272\u540d\u548c\u5341\u516d\u8fdb\u5236\u989c\u8272\u7684 CSV \u6587\u4ef6\u8f6c\u6362\u4e3a\u5305\u542b\u989c\u8272\u540d\u548c rgb \u989c\u8272\u3002\u8fd9\u91cc\u4f7f\u7528 ",(0,i.kt)("inlineCode",{parentName:"p"},"csv")," \u5305\u5bf9 CSV \u6587\u4ef6\u8fdb\u884c\u8bfb\u5199\uff0c\u7136\u540e\u7528 ",(0,i.kt)("inlineCode",{parentName:"p"},"serde")," \u8fdb\u884c\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\u3002"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust,editable"},'#use error_chain::error_chain;\nuse csv::{Reader, Writer};\nuse serde::{de, Deserialize, Deserializer};\nuse std::str::FromStr;\n\n#error_chain! {\n#   foreign_links {\n#       CsvError(csv::Error);\n#       ParseInt(std::num::ParseIntError);\n#       CsvInnerError(csv::IntoInnerError<Writer<Vec<u8>>>);\n#       IO(std::fmt::Error);\n#       UTF8(std::string::FromUtf8Error);\n#   }\n#}\n\n#[derive(Debug)]\nstruct HexColor {\n    red: u8,\n    green: u8,\n    blue: u8,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Row {\n    color_name: String,\n    color: HexColor,\n}\n\nimpl FromStr for HexColor {\n    type Err = Error;\n\n    fn from_str(hex_color: &str) -> std::result::Result<Self, Self::Err> {\n        let trimmed = hex_color.trim_matches(\'#\');\n        if trimmed.len != 6 {\n            Err("Invalid length of hex string".into)\n        } else {\n            Ok(HexColor {\n                red: u8::from_str_radix(&trimmed[..2], 16)?,\n                green: u8::from_str_radix(&trimmed[2..4], 16)?,\n                blue: u8::from_str_radix(&trimmed[4..6], 16)?,\n            })\n        }\n    }\n}\n\nimpl<\'de> Deserialize<\'de> for HexColor {\n    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>\n    where\n        D: Deserializer<\'de>,\n    {\n        let s = String::deserialize(deserializer)?;\n        FromStr::from_str(&s).map_err(de::Error::custom)\n    }\n}\n\nfn main -> Result<> {\n    let data = "color_name,color\nred,#ff0000\ngreen,#00ff00\nblue,#0000FF\nperiwinkle,#ccccff\nmagenta,#ff00ff"\n        .to_owned;\n    let mut out = Writer::from_writer(vec![]);\n    let mut reader = Reader::from_reader(data.as_bytes);\n    for result in reader.deserialize::<Row> {\n        let res = result?;\n        out.serialize((\n            res.color_name,\n            res.color.red,\n            res.color.green,\n            res.color.blue,\n        ))?;\n    }\n    let written = String::from_utf8(out.into_inner?)?;\n    assert_eq!(Some("magenta,255,0,255"), written.lines.last);\n    println!("{}", written);\n    Ok()\n}\n')))}m.isMDXComponent=!0}}]);