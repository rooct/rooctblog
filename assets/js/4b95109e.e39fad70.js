"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4021],{3905:function(t,n,e){e.d(n,{Zo:function(){return c},kt:function(){return m}});var a=e(7294);function r(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function i(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,a)}return e}function o(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?i(Object(e),!0).forEach((function(n){r(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):i(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function l(t,n){if(null==t)return{};var e,a,r=function(t,n){if(null==t)return{};var e,a,r={},i=Object.keys(t);for(a=0;a<i.length;a++)e=i[a],n.indexOf(e)>=0||(r[e]=t[e]);return r}(t,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(a=0;a<i.length;a++)e=i[a],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(r[e]=t[e])}return r}var s=a.createContext({}),d=function(t){var n=a.useContext(s),e=n;return t&&(e="function"==typeof t?t(n):o(o({},n),t)),e},c=function(t){var n=d(t.components);return a.createElement(s.Provider,{value:n},t.children)},u={inlineCode:"code",wrapper:function(t){var n=t.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(t,n){var e=t.components,r=t.mdxType,i=t.originalType,s=t.parentName,c=l(t,["components","mdxType","originalType","parentName"]),p=d(e),m=r,f=p["".concat(s,".").concat(m)]||p[m]||u[m]||i;return e?a.createElement(f,o(o({ref:n},c),{},{components:e})):a.createElement(f,o({ref:n},c))}));function m(t,n){var e=arguments,r=n&&n.mdxType;if("string"==typeof t||r){var i=e.length,o=new Array(i);o[0]=p;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=t,l.mdxType="string"==typeof t?t:r,o[1]=l;for(var d=2;d<i;d++)o[d]=e[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,e)}p.displayName="MDXCreateElement"},9405:function(t,n,e){e.r(n),e.d(n,{contentTitle:function(){return s},default:function(){return p},frontMatter:function(){return l},metadata:function(){return d},toc:function(){return c}});var a=e(7462),r=e(3366),i=(e(7294),e(3905)),o=["components"],l={},s="\u7edf\u8ba1",d={unversionedId:"rusty/algos/math/statistics",id:"rusty/algos/math/statistics",isDocsHomePage:!1,title:"\u7edf\u8ba1",description:"\u6d4b\u91cf\u4e2d\u5fc3\u8d8b\u52bf",source:"@site/docs/rusty/algos/math/statistics.md",sourceDirName:"rusty/algos/math",slug:"/rusty/algos/math/statistics",permalink:"/rooctblog/docs/rusty/algos/math/statistics",tags:[],version:"current",frontMatter:{},sidebar:"rust",previous:{title:"\u6742\u9879",permalink:"/rooctblog/docs/rusty/algos/math/misc"},next:{title:"\u4e09\u89d2\u51fd\u6570",permalink:"/rooctblog/docs/rusty/algos/math/trigonometry"}},c=[{value:"\u6d4b\u91cf\u4e2d\u5fc3\u8d8b\u52bf",id:"\u6d4b\u91cf\u4e2d\u5fc3\u8d8b\u52bf",children:[]},{value:"\u6807\u51c6\u504f\u5dee",id:"\u6807\u51c6\u504f\u5dee",children:[]}],u={toc:c};function p(t){var n=t.components,e=(0,r.Z)(t,o);return(0,i.kt)("wrapper",(0,a.Z)({},u,e,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"\u7edf\u8ba1"},"\u7edf\u8ba1"),(0,i.kt)("h3",{id:"\u6d4b\u91cf\u4e2d\u5fc3\u8d8b\u52bf"},"\u6d4b\u91cf\u4e2d\u5fc3\u8d8b\u52bf"),(0,i.kt)("p",null,"\u4e0b\u9762\u7684\u4e00\u4e9b\u4f8b\u5b50\u4e3a Rust \u6570\u7ec4\u4e2d\u7684\u6570\u636e\u8ba1\u7b97\u5b83\u4eec\u7684\u4e2d\u5fc3\u8d8b\u52bf\u3002"),(0,i.kt)("h4",{id:"\u5e73\u5747\u503c"},"\u5e73\u5747\u503c"),(0,i.kt)("p",null,"\u9996\u5148\u8ba1\u7b97\u7684\u662f\u5e73\u5747\u503c\u3002"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust,editable"},'fn main {\n    let data = [3, 1, 6, 1, 5, 8, 1, 8, 10, 11];\n\n    let sum = data.iter.sum::<i32> as f32;\n    let count = data.len;\n\n    let mean = match count {\n       positive if positive > 0 => Some(sum  / count as f32),\n       _ => None\n    };\n\n    println!("Mean of the data is {:?}", mean);\n}\n')),(0,i.kt)("h4",{id:"\u4e2d\u4f4d\u6570"},"\u4e2d\u4f4d\u6570"),(0,i.kt)("p",null,"\u4e0b\u9762\u4f7f\u7528\u5feb\u901f\u9009\u62e9\u7b97\u6cd5\u6765\u8ba1\u7b97\u4e2d\u4f4d\u6570\u3002\u8be5\u7b97\u6cd5\u53ea\u4f1a\u5bf9\u53ef\u80fd\u5305\u542b\u4e2d\u4f4d\u6570\u7684\u6570\u636e\u5206\u533a\u8fdb\u884c\u6392\u5e8f\uff0c\u4ece\u800c\u907f\u514d\u4e86\u5bf9\u6240\u6709\u6570\u636e\u8fdb\u884c\u5168\u6392\u5e8f\u3002"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust,editable"},'use std::cmp::Ordering;\n\nfn partition(data: &[i32]) -> Option<(Vec<i32>, i32, Vec<i32>)> {\n    match data.len {\n        0 => None,\n        _ => {\n            let (pivot_slice, tail) = data.split_at(1);\n            let pivot = pivot_slice[0];\n            let (left, right) = tail.iter\n                .fold((vec![], vec![]), |mut splits, next| {\n                    {\n                        let (ref mut left, ref mut right) = &mut splits;\n                        if next < &pivot {\n                            left.push(*next);\n                        } else {\n                            right.push(*next);\n                        }\n                    }\n                    splits\n                });\n\n            Some((left, pivot, right))\n        }\n    }\n}\n\nfn select(data: &[i32], k: usize) -> Option<i32> {\n    let part = partition(data);\n\n    match part {\n        None => None,\n        Some((left, pivot, right)) => {\n            let pivot_idx = left.len;\n\n            match pivot_idx.cmp(&k) {\n                Ordering::Equal => Some(pivot),\n                Ordering::Greater => select(&left, k),\n                Ordering::Less => select(&right, k - (pivot_idx + 1)),\n            }\n        },\n    }\n}\n\nfn median(data: &[i32]) -> Option<f32> {\n    let size = data.len;\n\n    match size {\n        even if even % 2 == 0 => {\n            let fst_med = select(data, (even / 2) - 1);\n            let snd_med = select(data, even / 2);\n\n            match (fst_med, snd_med) {\n                (Some(fst), Some(snd)) => Some((fst + snd) as f32 / 2.0),\n                _ => None\n            }\n        },\n        odd => select(data, odd / 2).map(|x| x as f32)\n    }\n}\n\nfn main {\n    let data = [3, 1, 6, 1, 5, 8, 1, 8, 10, 11];\n\n    let part = partition(&data);\n    println!("Partition is {:?}", part);\n\n    let sel = select(&data, 5);\n    println!("Selection at ordered index {} is {:?}", 5, sel);\n\n    let med = median(&data);\n    println!("Median is {:?}", med);\n}\n')),(0,i.kt)("h4",{id:"\u4f17\u6570-mode-"},"\u4f17\u6570( mode )"),(0,i.kt)("p",null,"\u4e0b\u9762\u4f7f\u7528\u4e86 ",(0,i.kt)("inlineCode",{parentName:"p"},"HashMap")," \u5bf9\u4e0d\u540c\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\u8fdb\u884c\u4e86\u5206\u522b\u7edf\u8ba1\u3002"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust,editable"},'use std::collections::HashMap;\n\nfn main {\n    let data = [3, 1, 6, 1, 5, 8, 1, 8, 10, 11];\n\n    let frequencies = data.iter.fold(HashMap::new, |mut freqs, value| {\n        *freqs.entry(value).or_insert(0) += 1;\n        freqs\n    });\n\n    let mode = frequencies\n        .into_iter\n        .max_by_key(|&(_, count)| count)\n        .map(|(value, _)| *value);\n\n    println!("Mode of the data is {:?}", mode);\n}\n')),(0,i.kt)("h3",{id:"\u6807\u51c6\u504f\u5dee"},"\u6807\u51c6\u504f\u5dee"),(0,i.kt)("p",null,"\u4e0b\u9762\u4e00\u8d77\u6765\u770b\u770b\u8be5\u5982\u4f55\u8ba1\u7b97\u4e00\u7ec4\u6d4b\u91cf\u503c\u7684\u6807\u51c6\u504f\u5dee\u548c z-score\u3002"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust,editable"},'fn mean(data: &[i32]) -> Option<f32> {\n    let sum = data.iter.sum::<i32> as f32;\n    let count = data.len;\n\n    match count {\n        positive if positive > 0 => Some(sum / count as f32),\n        _ => None,\n    }\n}\n\nfn std_deviation(data: &[i32]) -> Option<f32> {\n    match (mean(data), data.len) {\n        (Some(data_mean), count) if count > 0 => {\n            let variance = data.iter.map(|value| {\n                let diff = data_mean - (*value as f32);\n\n                diff * diff\n            }).sum::<f32> / count as f32;\n\n            Some(variance.sqrt)\n        },\n        _ => None\n    }\n}\n\nfn main {\n    let data = [3, 1, 6, 1, 5, 8, 1, 8, 10, 11];\n\n    let data_mean = mean(&data);\n    println!("Mean is {:?}", data_mean);\n\n    let data_std_deviation = std_deviation(&data);\n    println!("Standard deviation is {:?}", data_std_deviation);\n\n    let zscore = match (data_mean, data_std_deviation) {\n        (Some(mean), Some(std_deviation)) => {\n            let diff = data[4] as f32 - mean;\n\n            Some(diff / std_deviation)\n        },\n        _ => None\n    };\n    println!("Z-score of data at index 4 (with value {}) is {:?}", data[4], zscore);\n}\n')))}p.isMDXComponent=!0}}]);